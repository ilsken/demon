/* automatically generated by rust-bindgen */

pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = _IO_FILE;
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type nlink_t = __nlink_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_socktype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_canonname as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
pub type __u8 = ::std::os::raw::c_uchar;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __kernel_sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_nl {
    pub nl_family: __kernel_sa_family_t,
    pub nl_pad: ::std::os::raw::c_ushort,
    pub nl_pid: __u32,
    pub nl_groups: __u32,
}
#[test]
fn bindgen_test_layout_sockaddr_nl() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_nl>(),
        12usize,
        concat!("Size of: ", stringify!(sockaddr_nl))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_nl>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_nl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_nl),
            "::",
            stringify!(nl_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_nl),
            "::",
            stringify!(nl_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_nl),
            "::",
            stringify!(nl_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_nl>())).nl_groups as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_nl),
            "::",
            stringify!(nl_groups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[test]
fn bindgen_test_layout_nlmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<nlmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(nlmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nlmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nlmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsghdr>())).nlmsg_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsghdr),
            "::",
            stringify!(nlmsg_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmsgerr {
    pub error: ::std::os::raw::c_int,
    pub msg: nlmsghdr,
}
#[test]
fn bindgen_test_layout_nlmsgerr() {
    assert_eq!(
        ::std::mem::size_of::<nlmsgerr>(),
        20usize,
        concat!("Size of: ", stringify!(nlmsgerr))
    );
    assert_eq!(
        ::std::mem::align_of::<nlmsgerr>(),
        4usize,
        concat!("Alignment of ", stringify!(nlmsgerr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsgerr>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsgerr),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlmsgerr>())).msg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nlmsgerr),
            "::",
            stringify!(msg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_pktinfo {
    pub group: __u32,
}
#[test]
fn bindgen_test_layout_nl_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<nl_pktinfo>(),
        4usize,
        concat!("Size of: ", stringify!(nl_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nl_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(nl_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_pktinfo>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_pktinfo),
            "::",
            stringify!(group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_mmap_req {
    pub nm_block_size: ::std::os::raw::c_uint,
    pub nm_block_nr: ::std::os::raw::c_uint,
    pub nm_frame_size: ::std::os::raw::c_uint,
    pub nm_frame_nr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nl_mmap_req() {
    assert_eq!(
        ::std::mem::size_of::<nl_mmap_req>(),
        16usize,
        concat!("Size of: ", stringify!(nl_mmap_req))
    );
    assert_eq!(
        ::std::mem::align_of::<nl_mmap_req>(),
        4usize,
        concat!("Alignment of ", stringify!(nl_mmap_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_block_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_req),
            "::",
            stringify!(nm_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_block_nr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_req),
            "::",
            stringify!(nm_block_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_frame_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_req),
            "::",
            stringify!(nm_frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_req>())).nm_frame_nr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_req),
            "::",
            stringify!(nm_frame_nr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_mmap_hdr {
    pub nm_status: ::std::os::raw::c_uint,
    pub nm_len: ::std::os::raw::c_uint,
    pub nm_group: __u32,
    pub nm_pid: __u32,
    pub nm_uid: __u32,
    pub nm_gid: __u32,
}
#[test]
fn bindgen_test_layout_nl_mmap_hdr() {
    assert_eq!(
        ::std::mem::size_of::<nl_mmap_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(nl_mmap_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nl_mmap_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nl_mmap_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_mmap_hdr>())).nm_gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_mmap_hdr),
            "::",
            stringify!(nm_gid)
        )
    );
}
pub const nl_mmap_status_NL_MMAP_STATUS_UNUSED: nl_mmap_status = 0;
pub const nl_mmap_status_NL_MMAP_STATUS_RESERVED: nl_mmap_status = 1;
pub const nl_mmap_status_NL_MMAP_STATUS_VALID: nl_mmap_status = 2;
pub const nl_mmap_status_NL_MMAP_STATUS_COPY: nl_mmap_status = 3;
pub const nl_mmap_status_NL_MMAP_STATUS_SKIP: nl_mmap_status = 4;
pub type nl_mmap_status = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
#[test]
fn bindgen_test_layout_nlattr() {
    assert_eq!(
        ::std::mem::size_of::<nlattr>(),
        4usize,
        concat!("Size of: ", stringify!(nlattr))
    );
    assert_eq!(
        ::std::mem::align_of::<nlattr>(),
        2usize,
        concat!("Alignment of ", stringify!(nlattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlattr>())).nla_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nlattr),
            "::",
            stringify!(nla_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nlattr>())).nla_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nlattr),
            "::",
            stringify!(nla_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct genlmsghdr {
    pub cmd: __u8,
    pub version: __u8,
    pub reserved: __u16,
}
#[test]
fn bindgen_test_layout_genlmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<genlmsghdr>(),
        4usize,
        concat!("Size of: ", stringify!(genlmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<genlmsghdr>(),
        2usize,
        concat!("Alignment of ", stringify!(genlmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<genlmsghdr>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(genlmsghdr),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<genlmsghdr>())).version as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(genlmsghdr),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<genlmsghdr>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(genlmsghdr),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn nl_geterror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_perror(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nl_syserr2nlerr(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
///< Dump object briefly on one line
pub const nl_dump_type_NL_DUMP_LINE: nl_dump_type = 0;
///< Dump all attributes but no statistics
pub const nl_dump_type_NL_DUMP_DETAILS: nl_dump_type = 1;
///< Dump all attributes including statistics
pub const nl_dump_type_NL_DUMP_STATS: nl_dump_type = 2;
pub const nl_dump_type___NL_DUMP_MAX: nl_dump_type = 3;
/// @ingroup utils
/// Enumeration of dumping variations (dp_type)
pub type nl_dump_type = u32;
/// @ingroup utils
/// Dumping parameters
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_dump_params {
    /// Specifies the type of dump that is requested.
    pub dp_type: nl_dump_type,
    /// Specifies the number of whitespaces to be put in front
    /// of every new line (indentation).
    pub dp_prefix: ::std::os::raw::c_int,
    /// Causes the cache index to be printed for each element.
    pub dp_print_index: ::std::os::raw::c_int,
    /// Causes each element to be prefixed with the message type.
    pub dp_dump_msgtype: ::std::os::raw::c_int,
    /// A callback invoked for output
    ///
    /// Passed arguments are:
    ///  - dumping parameters
    ///  - string to append to the output
    pub dp_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut nl_dump_params, arg2: *mut ::std::os::raw::c_char),
    >,
    /// A callback invoked for every new line, can be used to
    /// customize the indentation.
    ///
    /// Passed arguments are:
    ///  - dumping parameters
    ///  - line number starting from 0
    pub dp_nl_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut nl_dump_params, arg2: ::std::os::raw::c_int),
    >,
    /// User data pointer, can be used to pass data to callbacks.
    pub dp_data: *mut ::std::os::raw::c_void,
    /// File descriptor the dumping output should go to
    pub dp_fd: *mut FILE,
    /// Alternatively the output may be redirected into a buffer
    pub dp_buf: *mut ::std::os::raw::c_char,
    /// Length of the buffer dp_buf
    pub dp_buflen: usize,
    /// PRIVATE
    /// Set if a dump was performed prior to the actual dump handler.
    pub dp_pre_dump: ::std::os::raw::c_int,
    /// PRIVATE
    /// Owned by the current caller
    pub dp_ivar: ::std::os::raw::c_int,
    pub dp_line: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nl_dump_params() {
    assert_eq!(
        ::std::mem::size_of::<nl_dump_params>(),
        80usize,
        concat!("Size of: ", stringify!(nl_dump_params))
    );
    assert_eq!(
        ::std::mem::align_of::<nl_dump_params>(),
        8usize,
        concat!("Alignment of ", stringify!(nl_dump_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_prefix as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_print_index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_print_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_dump_msgtype as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_dump_msgtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_cb as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_nl_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_nl_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_fd as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_buf as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_buflen as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_buflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_pre_dump as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_pre_dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_ivar as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_ivar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_dump_params>())).dp_line as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_dump_params),
            "::",
            stringify!(dp_line)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_cb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_msg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
/// nl_recvmsgs() callback for message processing customization
/// @ingroup cb
/// @arg msg		netlink message being processed
/// @arg arg		argument passwd on through caller
pub type nl_recvmsg_msg_cb_t = ::std::option::Option<
    unsafe extern "C" fn(msg: *mut nl_msg, arg: *mut ::std::os::raw::c_void)
                         -> ::std::os::raw::c_int,
>;
/// nl_recvmsgs() callback for error message processing customization
/// @ingroup cb
/// @arg nla		netlink address of the peer
/// @arg nlerr		netlink error message being processed
/// @arg arg		argument passed on through caller
pub type nl_recvmsg_err_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        nla: *mut sockaddr_nl,
        nlerr: *mut nlmsgerr,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
/// Proceed with wathever would come next
pub const nl_cb_action_NL_OK: nl_cb_action = 0;
/// Skip this message
pub const nl_cb_action_NL_SKIP: nl_cb_action = 1;
/// Stop parsing altogether and discard remaining messages
pub const nl_cb_action_NL_STOP: nl_cb_action = 2;
/// Callback actions
/// @ingroup cb
pub type nl_cb_action = u32;
/// Default handlers (quiet)
pub const nl_cb_kind_NL_CB_DEFAULT: nl_cb_kind = 0;
/// Verbose default handlers (error messages printed)
pub const nl_cb_kind_NL_CB_VERBOSE: nl_cb_kind = 1;
/// Debug handlers for debugging
pub const nl_cb_kind_NL_CB_DEBUG: nl_cb_kind = 2;
/// Customized handler specified by the user
pub const nl_cb_kind_NL_CB_CUSTOM: nl_cb_kind = 3;
/// Customized handler specified by the user
pub const nl_cb_kind___NL_CB_KIND_MAX: nl_cb_kind = 4;
/// Callback kinds
/// @ingroup cb
pub type nl_cb_kind = u32;
/// Message is valid
pub const nl_cb_type_NL_CB_VALID: nl_cb_type = 0;
/// Last message in a series of multi part messages received
pub const nl_cb_type_NL_CB_FINISH: nl_cb_type = 1;
/// Report received that data was lost
pub const nl_cb_type_NL_CB_OVERRUN: nl_cb_type = 2;
/// Message wants to be skipped
pub const nl_cb_type_NL_CB_SKIPPED: nl_cb_type = 3;
/// Message is an acknowledge
pub const nl_cb_type_NL_CB_ACK: nl_cb_type = 4;
/// Called for every message received
pub const nl_cb_type_NL_CB_MSG_IN: nl_cb_type = 5;
/// Called for every message sent out except for nl_sendto()
pub const nl_cb_type_NL_CB_MSG_OUT: nl_cb_type = 6;
/// Message is malformed and invalid
pub const nl_cb_type_NL_CB_INVALID: nl_cb_type = 7;
/// Called instead of internal sequence number checking
pub const nl_cb_type_NL_CB_SEQ_CHECK: nl_cb_type = 8;
/// Sending of an acknowledge message has been requested
pub const nl_cb_type_NL_CB_SEND_ACK: nl_cb_type = 9;
/// Flag NLM_F_DUMP_INTR is set in message
pub const nl_cb_type_NL_CB_DUMP_INTR: nl_cb_type = 10;
/// Flag NLM_F_DUMP_INTR is set in message
pub const nl_cb_type___NL_CB_TYPE_MAX: nl_cb_type = 11;
/// Callback types
/// @ingroup cb
pub type nl_cb_type = u32;
extern "C" {
    pub fn nl_cb_alloc(arg1: nl_cb_kind) -> *mut nl_cb;
}
extern "C" {
    pub fn nl_cb_clone(arg1: *mut nl_cb) -> *mut nl_cb;
}
extern "C" {
    pub fn nl_cb_get(arg1: *mut nl_cb) -> *mut nl_cb;
}
extern "C" {
    pub fn nl_cb_put(arg1: *mut nl_cb);
}
extern "C" {
    pub fn nl_cb_set(
        arg1: *mut nl_cb,
        arg2: nl_cb_type,
        arg3: nl_cb_kind,
        arg4: nl_recvmsg_msg_cb_t,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cb_set_all(
        arg1: *mut nl_cb,
        arg2: nl_cb_kind,
        arg3: nl_recvmsg_msg_cb_t,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cb_err(
        arg1: *mut nl_cb,
        arg2: nl_cb_kind,
        arg3: nl_recvmsg_err_cb_t,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cb_overwrite_recvmsgs(
        arg1: *mut nl_cb,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut nl_sock, arg2: *mut nl_cb) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn nl_cb_overwrite_recv(
        arg1: *mut nl_cb,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut nl_sock,
                arg2: *mut sockaddr_nl,
                arg3: *mut *mut ::std::os::raw::c_uchar,
                arg4: *mut *mut ucred,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn nl_cb_overwrite_send(
        arg1: *mut nl_cb,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn nl_cb_active_type(cb: *mut nl_cb) -> nl_cb_type;
}
extern "C" {
    pub fn nl_socket_alloc() -> *mut nl_sock;
}
extern "C" {
    pub fn nl_socket_alloc_cb(arg1: *mut nl_cb) -> *mut nl_sock;
}
extern "C" {
    pub fn nl_socket_free(arg1: *mut nl_sock);
}
extern "C" {
    pub fn nl_socket_get_local_port(arg1: *const nl_sock) -> u32;
}
extern "C" {
    pub fn nl_socket_set_local_port(arg1: *mut nl_sock, arg2: u32);
}
extern "C" {
    pub fn nl_socket_add_memberships(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_add_membership(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_drop_memberships(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_drop_membership(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_join_groups(arg1: *mut nl_sock, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nl_socket_get_peer_port(arg1: *const nl_sock) -> u32;
}
extern "C" {
    pub fn nl_socket_set_peer_port(arg1: *mut nl_sock, arg2: u32);
}
extern "C" {
    pub fn nl_socket_get_peer_groups(sk: *const nl_sock) -> u32;
}
extern "C" {
    pub fn nl_socket_set_peer_groups(sk: *mut nl_sock, groups: u32);
}
extern "C" {
    pub fn nl_socket_get_cb(arg1: *const nl_sock) -> *mut nl_cb;
}
extern "C" {
    pub fn nl_socket_set_cb(arg1: *mut nl_sock, arg2: *mut nl_cb);
}
extern "C" {
    pub fn nl_socket_modify_cb(
        arg1: *mut nl_sock,
        arg2: nl_cb_type,
        arg3: nl_cb_kind,
        arg4: nl_recvmsg_msg_cb_t,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_modify_err_cb(
        arg1: *mut nl_sock,
        arg2: nl_cb_kind,
        arg3: nl_recvmsg_err_cb_t,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_set_buffer_size(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_set_msg_buf_size(arg1: *mut nl_sock, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_get_msg_buf_size(arg1: *mut nl_sock) -> usize;
}
extern "C" {
    pub fn nl_socket_set_passcred(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_recv_pktinfo(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_disable_seq_check(arg1: *mut nl_sock);
}
extern "C" {
    pub fn nl_socket_use_seq(arg1: *mut nl_sock) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn nl_socket_disable_auto_ack(arg1: *mut nl_sock);
}
extern "C" {
    pub fn nl_socket_enable_auto_ack(arg1: *mut nl_sock);
}
extern "C" {
    pub fn nl_socket_get_fd(arg1: *const nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_set_fd(
        sk: *mut nl_sock,
        protocol: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_set_nonblocking(arg1: *const nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_socket_enable_msg_peek(arg1: *mut nl_sock);
}
extern "C" {
    pub fn nl_socket_disable_msg_peek(arg1: *mut nl_sock);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_list_head {
    pub next: *mut nl_list_head,
    pub prev: *mut nl_list_head,
}
#[test]
fn bindgen_test_layout_nl_list_head() {
    assert_eq!(
        ::std::mem::size_of::<nl_list_head>(),
        16usize,
        concat!("Size of: ", stringify!(nl_list_head))
    );
    assert_eq!(
        ::std::mem::align_of::<nl_list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(nl_list_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nl_list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nl_list_head),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    pub fn nl_cancel_down_bytes(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn nl_cancel_down_bits(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn nl_rate2str(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cancel_down_us(arg1: u32, arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nl_size2int(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nl_size2str(
        arg1: usize,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_prob2int(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nl_get_user_hz() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_get_psched_hz() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_us2ticks(arg1: u32) -> u32;
}
extern "C" {
    pub fn nl_ticks2us(arg1: u32) -> u32;
}
extern "C" {
    pub fn nl_str2msec(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_msec2str(
        arg1: u64,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_llproto2str(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_str2llproto(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_ether_proto2str(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_str2ether_proto(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_ip_proto2str(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_str2ip_proto(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_new_line(arg1: *mut nl_dump_params);
}
extern "C" {
    pub fn nl_dump(arg1: *mut nl_dump_params, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn nl_dump_line(arg1: *mut nl_dump_params, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn nl_has_capability(capability: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_object_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nl_object_alloc(arg1: *mut nl_object_ops) -> *mut nl_object;
}
extern "C" {
    pub fn nl_object_alloc_name(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut nl_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_object_free(arg1: *mut nl_object);
}
extern "C" {
    pub fn nl_object_clone(obj: *mut nl_object) -> *mut nl_object;
}
extern "C" {
    pub fn nl_object_update(dst: *mut nl_object, src: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_object_get(arg1: *mut nl_object);
}
extern "C" {
    pub fn nl_object_put(arg1: *mut nl_object);
}
extern "C" {
    pub fn nl_object_shared(arg1: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_object_dump(arg1: *mut nl_object, arg2: *mut nl_dump_params);
}
extern "C" {
    pub fn nl_object_dump_buf(arg1: *mut nl_object, arg2: *mut ::std::os::raw::c_char, arg3: usize);
}
extern "C" {
    pub fn nl_object_identical(arg1: *mut nl_object, arg2: *mut nl_object)
                               -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_object_diff(arg1: *mut nl_object, arg2: *mut nl_object) -> u32;
}
extern "C" {
    pub fn nl_object_match_filter(
        arg1: *mut nl_object,
        arg2: *mut nl_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_object_attrs2str(
        arg1: *mut nl_object,
        attrs: u32,
        buf: *mut ::std::os::raw::c_char,
        arg2: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_object_attr_list(
        arg1: *mut nl_object,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_object_keygen(arg1: *mut nl_object, arg2: *mut u32, arg3: u32);
}
extern "C" {
    pub fn nl_object_mark(arg1: *mut nl_object);
}
extern "C" {
    pub fn nl_object_unmark(arg1: *mut nl_object);
}
extern "C" {
    pub fn nl_object_is_marked(arg1: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_object_get_refcnt(arg1: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_object_get_cache(arg1: *mut nl_object) -> *mut nl_cache;
}
extern "C" {
    pub fn nl_object_get_type(arg1: *const nl_object) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_object_get_msgtype(arg1: *const nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_object_get_ops(arg1: *const nl_object) -> *mut nl_object_ops;
}
extern "C" {
    pub fn nl_object_get_id_attrs(obj: *mut nl_object) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_cache_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_parser_param {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nl_connect(arg1: *mut nl_sock, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_close(arg1: *mut nl_sock);
}
extern "C" {
    pub fn nl_sendto(
        arg1: *mut nl_sock,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_sendmsg(
        arg1: *mut nl_sock,
        arg2: *mut nl_msg,
        arg3: *mut msghdr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_send(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_send_iovec(
        arg1: *mut nl_sock,
        arg2: *mut nl_msg,
        arg3: *mut iovec,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_complete_msg(arg1: *mut nl_sock, arg2: *mut nl_msg);
}
extern "C" {
    pub fn nl_auto_complete(arg1: *mut nl_sock, arg2: *mut nl_msg);
}
extern "C" {
    pub fn nl_send_auto(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_send_auto_complete(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_send_sync(arg1: *mut nl_sock, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_send_simple(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_recv(
        arg1: *mut nl_sock,
        arg2: *mut sockaddr_nl,
        arg3: *mut *mut ::std::os::raw::c_uchar,
        arg4: *mut *mut ucred,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_recvmsgs(arg1: *mut nl_sock, arg2: *mut nl_cb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_recvmsgs_report(arg1: *mut nl_sock, arg2: *mut nl_cb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_recvmsgs_default(arg1: *mut nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_wait_for_ack(arg1: *mut nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_pickup(
        arg1: *mut nl_sock,
        parser: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut nl_cache_ops,
                arg2: *mut sockaddr_nl,
                arg3: *mut nlmsghdr,
                arg4: *mut nl_parser_param,
            ) -> ::std::os::raw::c_int,
        >,
        arg2: *mut *mut nl_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_pickup_keep_syserr(
        sk: *mut nl_sock,
        parser: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut nl_cache_ops,
                arg2: *mut sockaddr_nl,
                arg3: *mut nlmsghdr,
                arg4: *mut nl_parser_param,
            ) -> ::std::os::raw::c_int,
        >,
        result: *mut *mut nl_object,
        syserror: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_nlfamily2str(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_str2nlfamily(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_addr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nl_addr_alloc(arg1: usize) -> *mut nl_addr;
}
extern "C" {
    pub fn nl_addr_alloc_attr(arg1: *const nlattr, arg2: ::std::os::raw::c_int) -> *mut nl_addr;
}
extern "C" {
    pub fn nl_addr_build(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> *mut nl_addr;
}
extern "C" {
    pub fn nl_addr_parse(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut nl_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_clone(arg1: *const nl_addr) -> *mut nl_addr;
}
extern "C" {
    pub fn nl_addr_get(arg1: *mut nl_addr) -> *mut nl_addr;
}
extern "C" {
    pub fn nl_addr_put(arg1: *mut nl_addr);
}
extern "C" {
    pub fn nl_addr_shared(arg1: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_cmp(arg1: *const nl_addr, arg2: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_cmp_prefix(arg1: *const nl_addr, arg2: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_iszero(arg1: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_valid(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_guess_family(arg1: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_fill_sockaddr(
        arg1: *const nl_addr,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_info(arg1: *const nl_addr, arg2: *mut *mut addrinfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_resolve(
        arg1: *const nl_addr,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_set_family(arg1: *mut nl_addr, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nl_addr_get_family(arg1: *const nl_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_set_binary_addr(
        arg1: *mut nl_addr,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr_get_binary_addr(arg1: *const nl_addr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nl_addr_get_len(arg1: *const nl_addr) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn nl_addr_set_prefixlen(arg1: *mut nl_addr, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nl_addr_get_prefixlen(arg1: *const nl_addr) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn nl_af2str(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_str2af(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_addr2str(
        arg1: *const nl_addr,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_data {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nl_data_alloc(arg1: *const ::std::os::raw::c_void, arg2: usize) -> *mut nl_data;
}
extern "C" {
    pub fn nl_data_alloc_attr(arg1: *const nlattr) -> *mut nl_data;
}
extern "C" {
    pub fn nl_data_clone(arg1: *const nl_data) -> *mut nl_data;
}
extern "C" {
    pub fn nl_data_append(
        arg1: *mut nl_data,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_data_free(arg1: *mut nl_data);
}
extern "C" {
    pub fn nl_data_get(arg1: *const nl_data) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nl_data_get_size(arg1: *const nl_data) -> usize;
}
extern "C" {
    pub fn nl_data_cmp(arg1: *const nl_data, arg2: *const nl_data) -> ::std::os::raw::c_int;
}
/// @ingroup attr
/// Attribute validation policy.
///
/// See section @core_doc{core_attr_parse,Attribute Parsing} for more details.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nla_policy {
    /// Type of attribute or NLA_UNSPEC
    pub type_: u16,
    /// Minimal length of payload required
    pub minlen: u16,
    /// Maximal length of payload allowed
    pub maxlen: u16,
}
#[test]
fn bindgen_test_layout_nla_policy() {
    assert_eq!(
        ::std::mem::size_of::<nla_policy>(),
        6usize,
        concat!("Size of: ", stringify!(nla_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<nla_policy>(),
        2usize,
        concat!("Alignment of ", stringify!(nla_policy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nla_policy>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nla_policy>())).minlen as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy),
            "::",
            stringify!(minlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nla_policy>())).maxlen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nla_policy),
            "::",
            stringify!(maxlen)
        )
    );
}
extern "C" {
    pub fn nla_attr_size(payload: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_total_size(payload: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_padlen(payload: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_type(arg1: *const nlattr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_data(arg1: *const nlattr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nla_len(arg1: *const nlattr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_ok(arg1: *const nlattr, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_next(arg1: *const nlattr, arg2: *mut ::std::os::raw::c_int) -> *mut nlattr;
}
extern "C" {
    pub fn nla_parse(
        arg1: *mut *mut nlattr,
        arg2: ::std::os::raw::c_int,
        arg3: *mut nlattr,
        arg4: ::std::os::raw::c_int,
        arg5: *mut nla_policy,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_validate(
        arg1: *const nlattr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const nla_policy,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_find(
        arg1: *const nlattr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut nlattr;
}
extern "C" {
    pub fn nla_memcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const nlattr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const nlattr,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn nla_memcmp(
        arg1: *const nlattr,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_strcmp(
        arg1: *const nlattr,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_reserve(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut nlattr;
}
extern "C" {
    pub fn nla_put(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_put_data(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: *const nl_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_put_addr(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: *mut nl_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_s8(arg1: *const nlattr) -> i8;
}
extern "C" {
    pub fn nla_put_s8(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: i8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_u8(arg1: *const nlattr) -> u8;
}
extern "C" {
    pub fn nla_put_u8(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_s16(arg1: *const nlattr) -> i16;
}
extern "C" {
    pub fn nla_put_s16(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: i16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_u16(arg1: *const nlattr) -> u16;
}
extern "C" {
    pub fn nla_put_u16(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_s32(arg1: *const nlattr) -> i32;
}
extern "C" {
    pub fn nla_put_s32(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_u32(arg1: *const nlattr) -> u32;
}
extern "C" {
    pub fn nla_put_u32(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_s64(arg1: *const nlattr) -> i64;
}
extern "C" {
    pub fn nla_put_s64(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_u64(arg1: *const nlattr) -> u64;
}
extern "C" {
    pub fn nla_put_u64(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_string(arg1: *const nlattr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nla_strdup(arg1: *const nlattr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nla_put_string(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_flag(arg1: *const nlattr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_put_flag(arg1: *mut nl_msg, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_get_msecs(arg1: *const nlattr) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn nla_put_msecs(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_put_nested(
        arg1: *mut nl_msg,
        arg2: ::std::os::raw::c_int,
        arg3: *const nl_msg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_nest_start(arg1: *mut nl_msg, arg2: ::std::os::raw::c_int) -> *mut nlattr;
}
extern "C" {
    pub fn nla_nest_end(arg1: *mut nl_msg, arg2: *mut nlattr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_nest_cancel(arg1: *mut nl_msg, arg2: *const nlattr);
}
extern "C" {
    pub fn nla_parse_nested(
        arg1: *mut *mut nlattr,
        arg2: ::std::os::raw::c_int,
        arg3: *mut nlattr,
        arg4: *mut nla_policy,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nla_is_nested(arg1: *const nlattr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_tree {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nlmsg_size(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_total_size(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_padlen(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_data(arg1: *const nlmsghdr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nlmsg_datalen(arg1: *const nlmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_tail(arg1: *const nlmsghdr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nlmsg_attrdata(arg1: *const nlmsghdr, arg2: ::std::os::raw::c_int) -> *mut nlattr;
}
extern "C" {
    pub fn nlmsg_attrlen(
        arg1: *const nlmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_valid_hdr(
        arg1: *const nlmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_ok(arg1: *const nlmsghdr, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_next(arg1: *mut nlmsghdr, arg2: *mut ::std::os::raw::c_int) -> *mut nlmsghdr;
}
extern "C" {
    pub fn nlmsg_parse(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut nlattr,
        arg4: ::std::os::raw::c_int,
        arg5: *mut nla_policy,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_find_attr(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut nlattr;
}
extern "C" {
    pub fn nlmsg_validate(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut nla_policy,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_alloc() -> *mut nl_msg;
}
extern "C" {
    pub fn nlmsg_alloc_size(arg1: usize) -> *mut nl_msg;
}
extern "C" {
    pub fn nlmsg_alloc_simple(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> *mut nl_msg;
}
extern "C" {
    pub fn nlmsg_set_default_size(arg1: usize);
}
extern "C" {
    pub fn nlmsg_inherit(arg1: *mut nlmsghdr) -> *mut nl_msg;
}
extern "C" {
    pub fn nlmsg_convert(arg1: *mut nlmsghdr) -> *mut nl_msg;
}
extern "C" {
    pub fn nlmsg_reserve(
        arg1: *mut nl_msg,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nlmsg_append(
        arg1: *mut nl_msg,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_expand(arg1: *mut nl_msg, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_put(
        arg1: *mut nl_msg,
        arg2: u32,
        arg3: u32,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> *mut nlmsghdr;
}
extern "C" {
    pub fn nlmsg_hdr(arg1: *mut nl_msg) -> *mut nlmsghdr;
}
extern "C" {
    pub fn nlmsg_get(arg1: *mut nl_msg);
}
extern "C" {
    pub fn nlmsg_free(arg1: *mut nl_msg);
}
extern "C" {
    pub fn nlmsg_set_proto(arg1: *mut nl_msg, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nlmsg_get_proto(arg1: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nlmsg_get_max_size(arg1: *mut nl_msg) -> usize;
}
extern "C" {
    pub fn nlmsg_set_src(arg1: *mut nl_msg, arg2: *mut sockaddr_nl);
}
extern "C" {
    pub fn nlmsg_get_src(arg1: *mut nl_msg) -> *mut sockaddr_nl;
}
extern "C" {
    pub fn nlmsg_set_dst(arg1: *mut nl_msg, arg2: *mut sockaddr_nl);
}
extern "C" {
    pub fn nlmsg_get_dst(arg1: *mut nl_msg) -> *mut sockaddr_nl;
}
extern "C" {
    pub fn nlmsg_set_creds(arg1: *mut nl_msg, arg2: *mut ucred);
}
extern "C" {
    pub fn nlmsg_get_creds(arg1: *mut nl_msg) -> *mut ucred;
}
extern "C" {
    pub fn nl_nlmsgtype2str(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_str2nlmsgtype(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_nlmsg_flags2str(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nl_msg_parse(
        arg1: *mut nl_msg,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut nl_object, arg2: *mut ::std::os::raw::c_void),
        >,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_msg_dump(arg1: *mut nl_msg, arg2: *mut FILE);
}
extern "C" {
    pub fn genl_connect(arg1: *mut nl_sock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genl_send_simple(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genlmsg_put(
        arg1: *mut nl_msg,
        arg2: u32,
        arg3: u32,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: u8,
        arg8: u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn genlmsg_valid_hdr(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genlmsg_validate(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut nla_policy,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genlmsg_parse(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut nlattr,
        arg4: ::std::os::raw::c_int,
        arg5: *mut nla_policy,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genlmsg_hdr(arg1: *mut nlmsghdr) -> *mut genlmsghdr;
}
extern "C" {
    pub fn genlmsg_data(arg1: *const genlmsghdr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn genlmsg_user_hdr(arg1: *const genlmsghdr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn genlmsg_user_data(
        arg1: *const genlmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn genlmsg_user_datalen(
        arg1: *const genlmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genlmsg_len(arg1: *const genlmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genlmsg_attrdata(arg1: *const genlmsghdr, arg2: ::std::os::raw::c_int) -> *mut nlattr;
}
extern "C" {
    pub fn genlmsg_attrlen(
        arg1: *const genlmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genl_op2name(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> *mut ::std::os::raw::c_char;
}
pub type change_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nl_cache,
        arg2: *mut nl_object,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn nl_cache_nitems(arg1: *mut nl_cache) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_nitems_filter(
        arg1: *mut nl_cache,
        arg2: *mut nl_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_get_ops(arg1: *mut nl_cache) -> *mut nl_cache_ops;
}
extern "C" {
    pub fn nl_cache_get_first(arg1: *mut nl_cache) -> *mut nl_object;
}
extern "C" {
    pub fn nl_cache_get_last(arg1: *mut nl_cache) -> *mut nl_object;
}
extern "C" {
    pub fn nl_cache_get_next(arg1: *mut nl_object) -> *mut nl_object;
}
extern "C" {
    pub fn nl_cache_get_prev(arg1: *mut nl_object) -> *mut nl_object;
}
extern "C" {
    pub fn nl_cache_alloc(arg1: *mut nl_cache_ops) -> *mut nl_cache;
}
extern "C" {
    pub fn nl_cache_alloc_and_fill(
        arg1: *mut nl_cache_ops,
        arg2: *mut nl_sock,
        arg3: *mut *mut nl_cache,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_alloc_name(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut nl_cache,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_subset(arg1: *mut nl_cache, arg2: *mut nl_object) -> *mut nl_cache;
}
extern "C" {
    pub fn nl_cache_clone(arg1: *mut nl_cache) -> *mut nl_cache;
}
extern "C" {
    pub fn nl_cache_clear(arg1: *mut nl_cache);
}
extern "C" {
    pub fn nl_cache_get(arg1: *mut nl_cache);
}
extern "C" {
    pub fn nl_cache_free(arg1: *mut nl_cache);
}
extern "C" {
    pub fn nl_cache_put(cache: *mut nl_cache);
}
extern "C" {
    pub fn nl_cache_add(arg1: *mut nl_cache, arg2: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_parse_and_add(arg1: *mut nl_cache, arg2: *mut nl_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_move(arg1: *mut nl_cache, arg2: *mut nl_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_remove(arg1: *mut nl_object);
}
extern "C" {
    pub fn nl_cache_refill(arg1: *mut nl_sock, arg2: *mut nl_cache) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_pickup(arg1: *mut nl_sock, arg2: *mut nl_cache) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_pickup_checkdup(
        arg1: *mut nl_sock,
        arg2: *mut nl_cache,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_resync(
        arg1: *mut nl_sock,
        arg2: *mut nl_cache,
        arg3: change_func_t,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_include(
        arg1: *mut nl_cache,
        arg2: *mut nl_object,
        arg3: change_func_t,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_set_arg1(arg1: *mut nl_cache, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nl_cache_set_arg2(arg1: *mut nl_cache, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nl_cache_set_flags(arg1: *mut nl_cache, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn nl_cache_is_empty(arg1: *mut nl_cache) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_search(arg1: *mut nl_cache, arg2: *mut nl_object) -> *mut nl_object;
}
extern "C" {
    pub fn nl_cache_find(arg1: *mut nl_cache, arg2: *mut nl_object) -> *mut nl_object;
}
extern "C" {
    pub fn nl_cache_mark_all(arg1: *mut nl_cache);
}
extern "C" {
    pub fn nl_cache_dump(arg1: *mut nl_cache, arg2: *mut nl_dump_params);
}
extern "C" {
    pub fn nl_cache_dump_filter(
        arg1: *mut nl_cache,
        arg2: *mut nl_dump_params,
        arg3: *mut nl_object,
    );
}
extern "C" {
    pub fn nl_cache_foreach(
        arg1: *mut nl_cache,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut nl_object, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn nl_cache_foreach_filter(
        arg1: *mut nl_cache,
        arg2: *mut nl_object,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut nl_object, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn nl_cache_ops_lookup(arg1: *const ::std::os::raw::c_char) -> *mut nl_cache_ops;
}
extern "C" {
    pub fn nl_cache_ops_lookup_safe(arg1: *const ::std::os::raw::c_char) -> *mut nl_cache_ops;
}
extern "C" {
    pub fn nl_cache_ops_associate(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> *mut nl_cache_ops;
}
extern "C" {
    pub fn nl_cache_ops_associate_safe(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> *mut nl_cache_ops;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_msgtype {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nl_msgtype_lookup(
        arg1: *mut nl_cache_ops,
        arg2: ::std::os::raw::c_int,
    ) -> *mut nl_msgtype;
}
extern "C" {
    pub fn nl_cache_ops_foreach(
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut nl_cache_ops, arg2: *mut ::std::os::raw::c_void),
        >,
        arg1: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn nl_cache_mngt_register(arg1: *mut nl_cache_ops) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_mngt_unregister(arg1: *mut nl_cache_ops) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_mngt_provide(arg1: *mut nl_cache);
}
extern "C" {
    pub fn nl_cache_mngt_unprovide(arg1: *mut nl_cache);
}
extern "C" {
    pub fn nl_cache_mngt_require(arg1: *const ::std::os::raw::c_char) -> *mut nl_cache;
}
extern "C" {
    pub fn nl_cache_mngt_require_safe(arg1: *const ::std::os::raw::c_char) -> *mut nl_cache;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl_cache_mngr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nl_cache_mngr_alloc(
        arg1: *mut nl_sock,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut *mut nl_cache_mngr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_mngr_add(
        arg1: *mut nl_cache_mngr,
        arg2: *const ::std::os::raw::c_char,
        arg3: change_func_t,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut *mut nl_cache,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_mngr_add_cache(
        mngr: *mut nl_cache_mngr,
        cache: *mut nl_cache,
        cb: change_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_mngr_get_fd(arg1: *mut nl_cache_mngr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_mngr_poll(
        arg1: *mut nl_cache_mngr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_mngr_data_ready(arg1: *mut nl_cache_mngr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nl_cache_mngr_info(arg1: *mut nl_cache_mngr, arg2: *mut nl_dump_params);
}
extern "C" {
    pub fn nl_cache_mngr_free(arg1: *mut nl_cache_mngr);
}
extern "C" {
    pub fn nl_cache_ops_get(arg1: *mut nl_cache_ops);
}
extern "C" {
    pub fn nl_cache_ops_put(arg1: *mut nl_cache_ops);
}
extern "C" {
    pub fn nl_cache_ops_set_flags(arg1: *mut nl_cache_ops, arg2: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct genl_family {
    _unused: [u8; 0],
}
extern "C" {
    pub fn genl_ctrl_alloc_cache(
        arg1: *mut nl_sock,
        arg2: *mut *mut nl_cache,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genl_ctrl_search(arg1: *mut nl_cache, arg2: ::std::os::raw::c_int) -> *mut genl_family;
}
extern "C" {
    pub fn genl_ctrl_search_by_name(
        arg1: *mut nl_cache,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut genl_family;
}
extern "C" {
    pub fn genl_ctrl_resolve(
        arg1: *mut nl_sock,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genl_ctrl_resolve_grp(
        sk: *mut nl_sock,
        family: *const ::std::os::raw::c_char,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
